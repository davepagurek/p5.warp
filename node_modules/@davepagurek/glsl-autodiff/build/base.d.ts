export declare type Input = Op | number;
export interface ADBase {
    getNextID(): number;
    val(n: number): Value;
    registerParam(param: Op, name: string): any;
    param(name: string): Param;
    convertVal(param: Input): Op;
    convertVals(params: Input[]): Op[];
    output(name: string, op: Op): ADBase;
    outputDeriv(name: string, param: Param | string, op: Op): ADBase;
    settings: ADSettings;
}
export declare type ADSettings = {
    maxDepthPerVariable: number;
    debug: boolean;
};
export declare type ADConstructor = new (...args: any[]) => ADBase;
export declare const getStack: () => string[];
export declare function UserInput<T extends (...args: any[]) => Op>(fn: T): T;
export declare abstract class Op {
    ad: ADBase;
    id: number;
    dependsOn: Op[];
    usedIn: Op[];
    srcLine: string;
    internalDerivatives: {
        op: Op;
        param: Param;
    }[];
    constructor(ad: ADBase, ...params: Op[]);
    scalar(): boolean;
    size(): number;
    glslType(): string;
    depth(): number;
    useTempVar(): boolean;
    ref(): string;
    zeroDerivative(): string;
    derivRef(param: Param): string;
    initializer(): string;
    derivInitializer(param: Param): string;
    isConst(param?: Param): boolean;
    outputDependencies({ deps, derivDeps }: {
        deps: Set<Op>;
        derivDeps: Map<Param, Set<Op>>;
    }): string;
    outputDerivDependencies(param: Param, { deps, derivDeps }: {
        deps: Set<Op>;
        derivDeps: Map<Param, Set<Op>>;
    }): string;
    output(name: string): ADBase;
    outputDeriv(name: string, param: Param | string): ADBase;
    abstract definition(): string;
    abstract derivative(param: Param): string;
}
export declare abstract class BooleanOp extends Op {
    abstract operator(): string;
    definition(): string;
    derivative(): string;
    isConst(): boolean;
    glslType(): string;
}
export declare class EqOp extends BooleanOp {
    operator(): string;
}
export declare class NeOp extends BooleanOp {
    operator(): string;
}
export declare class LtOp extends BooleanOp {
    operator(): string;
}
export declare class LeOp extends BooleanOp {
    operator(): string;
}
export declare class GtOp extends BooleanOp {
    operator(): string;
}
export declare class GeOp extends BooleanOp {
    operator(): string;
}
export declare class NotOp extends BooleanOp {
    operator(): string;
    definition(): string;
}
export declare class AndOp extends BooleanOp {
    operator(): string;
}
export declare class OrOp extends BooleanOp {
    operator(): string;
}
export declare abstract class OpLiteral extends Op {
    initializer(): string;
    derivInitializer(): string;
    ref(): string;
    derivRef(param: Param): string;
}
export declare class Value extends OpLiteral {
    private val;
    constructor(ad: ADBase, val: number);
    isConst(): boolean;
    definition(): string;
    derivative(): string;
}
export declare class Param extends OpLiteral {
    name: string;
    constructor(ad: ADBase, name: string, ...dependsOn: Op[]);
    safeName(): string;
    isConst(param?: Param): boolean;
    definition(): string;
    derivative(param: Param): "0.0" | "1.0";
}
